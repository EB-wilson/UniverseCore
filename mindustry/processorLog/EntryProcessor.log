processor: EntryProcessor (full class name: universecore.annotations.EntryProcessor)
time: Tue May 30 10:45:44 CST 2023

-----------------------------------------
annotation: universecore.annotations.Annotations.ImplEntries
-----------------------------------------

> class: universecore.world.blocks.FakeBlock.FakeBuild
 1| 
 2| @Annotations.ImplEntries
 3| public class FakeBuild extends Building implements ReplaceBuildComp {
 4|     
 5|     public FakeBuild() {
 6|         super();
 7|     }
 8|     Building realBuild;
 9|     
10|     @Override
11|     public Building init(Tile tile, Team team, boolean shouldAdd, int rotation) {
12|         FieldHandler.setValueDefault(tile, "block", maskedBlock);
13|         realBuild = maskedBlock.newBuilding();
14|         this.tile = tile;
15|         this.x = tile.drawx();
16|         this.y = tile.drawy();
17|         this.rotation = rotation;
18|         this.team = team;
19|         realBuild.init(tile, team, shouldAdd, rotation);
20|         universecore.components.blockcomp.ReplaceBuildComp.super.buildInitialized();
21|         return realBuild;
22|     }
23|     
24|     @Override
25|     public void onReplaced(ReplaceBuildComp old) {
26|         if (realBuild instanceof ReplaceBuildComp re) {
27|             re.onReplaced(old);
28|         }
29|     }
30|     
31|     public mindustry.world.Tile getTile() {
32|         return super.tile;
33|     }
34|     
35|     public mindustry.world.modules.ItemModule items() {
36|         return super.items;
37|     }
38|     
39|     public mindustry.world.modules.LiquidModule liquids() {
40|         return super.liquids;
41|     }
42|     
43|     public void onRemoved() {
44|         super.onRemoved();
45|         universecore.components.blockcomp.ReplaceBuildComp.super.onRemoving();
46|     }
47| }

> class: universecore.world.particles.Particle
  1| 
  2| @Annotations.ImplEntries
  3| public class Particle extends Decal implements ExtraVariableComp, Iterable<Particle.Cloud> {
  4|     
  5|     public Particle() {
  6|         super();
  7|     }
  8|     public java.util.Map<java.lang.String, java.lang.Object> extraVar = new java.util.HashMap<>();
  9|     private static int counter = 0;
 10|     public static int maxAmount = 1024;
 11|     protected static final ObjectSet<Particle> all = new ObjectSet<>();
 12|     protected static final Seq<Particle> temp = new Seq<>();
 13|     protected Vec2 startPos = new Vec2();
 14|     protected float clipSize;
 15|     Cloud currentCloud;
 16|     Cloud firstCloud;
 17|     int cloudCount;
 18|     public Vec2 speed = new Vec2();
 19|     public float size;
 20|     public float defSpeed;
 21|     public float defSize;
 22|     public ParticleModel model;
 23|     public float layer;
 24|     
 25|     public static int count() {
 26|         return all.size;
 27|     }
 28|     
 29|     public static Seq<Particle> get(Boolf<Particle> filter) {
 30|         temp.clear();
 31|         for (Particle particle : all) {
 32|             if (filter.get(particle)) temp.add(particle);
 33|         }
 34|         return temp;
 35|     }
 36|     
 37|     @Override
 38|     public void add() {
 39|         index__all = Groups.all.addIndex(this);
 40|         index__draw = Groups.draw.addIndex(this);
 41|         all.add(this);
 42|         counter++;
 43|         currentCloud = Pools.get(Cloud.class, Cloud::new, 65536).obtain();
 44|         currentCloud.x = x;
 45|         currentCloud.y = y;
 46|         currentCloud.size = 0;
 47|         currentCloud.color.set(model.trailColor(this));
 48|         firstCloud = currentCloud;
 49|         added = true;
 50|         model.init(this);
 51|         if (counter >= maxAmount) {
 52|             remove();
 53|         }
 54|     }
 55|     
 56|     @Override
 57|     public void draw() {
 58|         float l = Draw.z();
 59|         Draw.z(layer);
 60|         model.draw(this);
 61|         if (currentCloud != null) {
 62|             model.drawTrail(this);
 63|         }
 64|         Draw.z(l);
 65|         Draw.reset();
 66|     }
 67|     
 68|     @Override
 69|     public void update() {
 70|         model.deflect(this);
 71|         x += speed.x * Time.delta;
 72|         y += speed.y * Time.delta;
 73|         size = model.currSize(this);
 74|         model.update(this);
 75|         Cloud c = Pools.get(Cloud.class, Cloud::new, 65536).obtain();
 76|         c.x = x;
 77|         c.y = y;
 78|         c.size = size;
 79|         c.color.set(model.trailColor(this));
 80|         c.perCloud = currentCloud;
 81|         currentCloud.nextCloud = c;
 82|         currentCloud = c;
 83|         cloudCount++;
 84|         for (Cloud cloud : currentCloud) {
 85|             model.updateTrail(this, cloud);
 86|         }
 87|         boolean mark = false;
 88|         while (firstCloud.nextCloud != null) {
 89|             if (model.isFaded(this, firstCloud)) {
 90|                 popFirst();
 91|                 mark = true;
 92|             } else break;
 93|         }
 94|         if (!mark && model.isFinal(this)) {
 95|             popFirst();
 96|             if (cloudCount > 4) popFirst();
 97|         }
 98|         if (cloudCount <= 4 && model.isFinal(this)) remove();
 99|     }
100|     
101|     private void popFirst() {
102|         Cloud n = firstCloud.nextCloud;
103|         n.perCloud = null;
104|         Pools.free(firstCloud);
105|         firstCloud = n;
106|         cloudCount--;
107|     }
108|     
109|     @Override
110|     public void remove() {
111|         if (added) {
112|             Groups.all.removeIndex(this, this.index__all);
113|             index__all = -1;
114|             Groups.draw.removeIndex(this, this.index__draw);
115|             index__draw = -1;
116|             Groups.queueFree(this);
117|             all.remove(this);
118|             counter--;
119|             added = false;
120|         }
121|     }
122|     
123|     @Override
124|     public int classId() {
125|         return 102;
126|     }
127|     
128|     @Override
129|     public float clipSize() {
130|         return clipSize = Math.max(Tmp.v1.set(x, y).sub(startPos).len(), clipSize);
131|     }
132|     
133|     @Override
134|     public void reset() {
135|         added = false;
136|         id = EntityGroup.nextId();
137|         lifetime = 0;
138|         region = null;
139|         rotation = 0;
140|         time = 0;
141|         x = 0;
142|         y = 0;
143|         speed.setZero();
144|         startPos.setZero();
145|         layer = 0;
146|         clipSize = 0;
147|         while (firstCloud.nextCloud != null) {
148|             popFirst();
149|         }
150|         Pools.free(firstCloud);
151|         currentCloud = null;
152|         firstCloud = null;
153|         cloudCount = 0;
154|         size = 0;
155|         extra().clear();
156|         model = null;
157|         color.set(Color.white);
158|     }
159|     
160|     @Override
161|     public Iterator<Cloud> iterator() {
162|         return currentCloud.iterator();
163|     }
164|     
165|     public static class Cloud implements Pool.Poolable, Iterable<Cloud> {
166|         
167|         public Cloud() {
168|             super();
169|         }
170|         public final Color color = new Color();
171|         public float x;
172|         public float y;
173|         public float size;
174|         public Cloud perCloud;
175|         public Cloud nextCloud;
176|         Itr itr = new Itr();
177|         
178|         public void draw() {
179|             Draw.color(color);
180|             if (perCloud != null && nextCloud != null) {
181|                 float angle = Angles.angle(x - perCloud.x, y - perCloud.y);
182|                 float dx1 = Angles.trnsx(angle + 90, size);
183|                 float dy1 = Angles.trnsy(angle + 90, size);
184|                 angle = Angles.angle(nextCloud.x - x, nextCloud.y - y);
185|                 float dx2 = Angles.trnsx(angle + 90, nextCloud.size);
186|                 float dy2 = Angles.trnsy(angle + 90, nextCloud.size);
187|                 Fill.quad(x + dx1, y + dy1, x - dx1, y - dy1, nextCloud.x - dx2, nextCloud.y - dy2, nextCloud.x + dx2, nextCloud.y + dy2);
188|             } else if (perCloud == null && nextCloud != null) {
189|                 float angle = Angles.angle(nextCloud.x - x, nextCloud.y - y);
190|                 float dx2 = Angles.trnsx(angle + 90, nextCloud.size);
191|                 float dy2 = Angles.trnsy(angle + 90, nextCloud.size);
192|                 Fill.quad(x, y, x, y, nextCloud.x - dx2, nextCloud.y - dy2, nextCloud.x + dx2, nextCloud.y + dy2);
193|             }
194|         }
195|         
196|         @Override
197|         public void reset() {
198|             x = 0;
199|             y = 0;
200|             size = 0;
201|             color.set(Color.clear);
202|             perCloud = null;
203|             nextCloud = null;
204|         }
205|         
206|         @SuppressWarnings(value = "ReturnOfInnerClass")
207|         @Override
208|         public Iterator<Cloud> iterator() {
209|             itr.reset();
210|             return itr;
211|         }
212|         
213|         class Itr implements Iterator<Cloud> {
214|             
215|             Itr() {
216|                 super();
217|             }
218|             Cloud curr = Cloud.this;
219|             
220|             public void reset() {
221|                 curr = Cloud.this;
222|             }
223|             
224|             @Override
225|             public boolean hasNext() {
226|                 return curr.perCloud != null;
227|             }
228|             
229|             @Override
230|             public Cloud next() {
231|                 return curr = curr.perCloud;
232|             }
233|         }
234|     }
235|     
236|     public java.util.Map<java.lang.String, java.lang.Object> extra() {
237|         return this.extraVar;
238|     }
239| }

> class: testbuild.Test
 1| 
 2| @Annotations.ImplEntries
 3| public class Test extends A implements I {
 4|     
 5|     public Test() {
 6|         super();
 7|     }
 8|     public int value;
 9|     
10|     @Override
11|     public void subTrigger(String arg) {
12|         I.super.subTrigger(arg);
13|         System.out.println(arg);
14|     }
15|     
16|     public void set(int i) {
17|         this.value = i;
18|     }
19|     
20|     public int get() {
21|         return this.value;
22|     }
23|     
24|     public void run(java.lang.String in) {
25|         super.run(in);
26|         this.subTrigger(in);
27|     }
28|     
29|     public int doing() {
30|         return testbuild.I.super.doing();
31|     }
32|     
33|     public java.lang.String transToUp(java.lang.String in) {
34|         return testbuild.I.super.transToUp(in);
35|     }
36|     
37|     public java.lang.String transToLow(java.lang.String in) {
38|         return testbuild.I.super.transToLow(in);
39|     }
40| }

