processor: EntryProcessor (full class name: universecore.annotations.EntryProcessor)
time: Sat Jul 22 17:15:16 CST 2023

-----------------------------------------
annotation: universecore.annotations.Annotations.ImplEntries
-----------------------------------------

> class: universecore.world.blocks.chains.ChainsContainer
  1| 
  2| @Annotations.ImplEntries
  3| public class ChainsContainer implements ExtraVariableComp {
  4|     
  5|     public ChainsContainer() {
  6|         super();
  7|     }
  8|     public java.util.Map<java.lang.String, java.lang.Object> extraVar = new universecore.util.colletion.CollectionObjectMap<>();
  9|     private static final Queue<ChainsBuildComp> findQueue = new Queue<>();
 10|     private static final ObjectSet<ChainsBuildComp> added = new ObjectSet<>();
 11|     public final OrderedSet<ChainsBuildComp> all = new OrderedSet<>();
 12|     private int minX;
 13|     private int minY;
 14|     private int maxX;
 15|     private int maxY;
 16|     private long lastFrameUpdated;
 17|     private boolean structUpdated = true;
 18|     
 19|     public boolean inlerp(ChainsBuildComp origin, ChainsBuildComp other) {
 20|         if (!all.contains(origin)) return false;
 21|         ChainsContainer otherContainer = other.chains().container;
 22|         return Math.max(maxX(), otherContainer.maxX()) - Math.min(minX(), otherContainer.minX()) < Math.min(origin.getChainsBlock().maxWidth(), other.getChainsBlock().maxWidth()) && Math.max(maxY(), otherContainer.maxY()) - Math.min(minY(), otherContainer.minY()) < Math.min(origin.getChainsBlock().maxHeight(), other.getChainsBlock().maxHeight());
 23|     }
 24|     
 25|     public int minX() {
 26|         return minX;
 27|     }
 28|     
 29|     public int maxX() {
 30|         return maxX;
 31|     }
 32|     
 33|     public int minY() {
 34|         return minY;
 35|     }
 36|     
 37|     public int maxY() {
 38|         return maxY;
 39|     }
 40|     
 41|     public int width() {
 42|         return maxX - minX + 1;
 43|     }
 44|     
 45|     public int height() {
 46|         return maxY - minY + 1;
 47|     }
 48|     
 49|     @Deprecated
 50|     public void putVar(String key, Object obj) {
 51|         setVar(key, obj);
 52|     }
 53|     
 54|     public void add(ChainsContainer other) {
 55|         for (ChainsBuildComp next : other.all) {
 56|             add(next);
 57|         }
 58|     }
 59|     
 60|     private void updateEdge(ChainsBuildComp other) {
 61|         float offset = other.getBlock().size / 2.0F;
 62|         float centOffset = other.getBlock().offset / tilesize;
 63|         if (all.isEmpty()) {
 64|             minX = (int)Math.ceil(other.tileX() + centOffset - offset);
 65|             minY = (int)Math.ceil(other.tileY() + centOffset - offset);
 66|             maxX = (int)Math.floor(other.tileX() + centOffset + offset);
 67|             maxY = (int)Math.floor(other.tileY() + centOffset + offset);
 68|         } else {
 69|             minX = Math.min(minX, (int)Math.ceil(other.tileX() + centOffset - offset));
 70|             minY = Math.min(minY, (int)Math.ceil(other.tileY() + centOffset - offset));
 71|             maxX = Math.max(maxX, (int)Math.floor(other.tileX() + centOffset + offset));
 72|             maxY = Math.max(maxY, (int)Math.floor(other.tileY() + centOffset + offset));
 73|         }
 74|     }
 75|     
 76|     public void add(ChainsBuildComp other) {
 77|         if (all.contains(other)) return;
 78|         updateEdge(other);
 79|         all.add(other);
 80|         ChainsContainer oldContainer = other.chains().container;
 81|         other.chains().container = this;
 82|         other.chainsAdded(oldContainer);
 83|         structUpdated = true;
 84|     }
 85|     
 86|     public void update() {
 87|         if (Core.graphics.getFrameId() == lastFrameUpdated) return;
 88|         lastFrameUpdated = Core.graphics.getFrameId();
 89|         if (structUpdated) {
 90|             for (ChainsBuildComp comp : all) {
 91|                 comp.onChainsUpdated();
 92|             }
 93|             structUpdated = false;
 94|         }
 95|     }
 96|     
 97|     public void reconstruct(ChainsBuildComp source, Boolf<ChainsBuildComp> filter) {
 98|         findQueue.clear();
 99|         added.clear();
100|         findQueue.addFirst(source);
101|         added.add(source);
102|         while (!findQueue.isEmpty()) {
103|             ChainsBuildComp other = findQueue.removeLast();
104|             for (ChainsBuildComp next : other.chainBuilds()) {
105|                 if (added.add(next) && filter.get(next)) findQueue.addFirst(next);
106|             }
107|             ChainsContainer oldContainer = other.chains().container;
108|             add(other);
109|             other.chainsFlowed(oldContainer);
110|         }
111|     }
112|     
113|     public void remove(ChainsBuildComp target) {
114|         Seq<ChainsBuildComp> children;
115|         for (ChainsBuildComp next : children = target.chainBuilds()) {
116|             if (!all.contains(next) || next.chains().container != this) continue;
117|             next.chains().newContainer().reconstruct(next, (e)->e != target && all.contains(e));
118|         }
119|         target.chainsRemoved(children);
120|     }
121|     
122|     public java.util.Map<java.lang.String, java.lang.Object> extra() {
123|         return this.extraVar;
124|     }
125| }

> class: universecore.world.blocks.FakeBlock.FakeBuild
 1| 
 2| @Annotations.ImplEntries
 3| public class FakeBuild extends Building implements ReplaceBuildComp {
 4|     
 5|     public FakeBuild() {
 6|         super();
 7|     }
 8|     Building realBuild;
 9|     
10|     @Override
11|     public Building init(Tile tile, Team team, boolean shouldAdd, int rotation) {
12|         FieldHandler.setValueDefault(tile, "block", maskedBlock);
13|         realBuild = maskedBlock.newBuilding();
14|         this.tile = tile;
15|         this.x = tile.drawx();
16|         this.y = tile.drawy();
17|         this.rotation = rotation;
18|         this.team = team;
19|         realBuild.init(tile, team, shouldAdd, rotation);
20|         this.buildInitialized();
21|         return realBuild;
22|     }
23|     
24|     @Override
25|     public void onReplaced(ReplaceBuildComp old) {
26|         if (realBuild instanceof ReplaceBuildComp re) {
27|             re.onReplaced(old);
28|         }
29|     }
30|     
31|     public mindustry.world.Tile getTile() {
32|         return super.tile;
33|     }
34|     
35|     public mindustry.world.modules.ItemModule items() {
36|         return super.items;
37|     }
38|     
39|     public mindustry.world.modules.LiquidModule liquids() {
40|         return super.liquids;
41|     }
42|     
43|     public void onRemoved() {
44|         super.onRemoved();
45|         this.onRemoving();
46|     }
47| }

> class: universecore.world.particles.Particle
  1| 
  2| @Annotations.ImplEntries
  3| public class Particle extends Decal implements ExtraVariableComp, Iterable<Particle.Cloud> {
  4|     
  5|     public Particle() {
  6|         super();
  7|     }
  8|     public java.util.Map<java.lang.String, java.lang.Object> extraVar = new universecore.util.colletion.CollectionObjectMap<>();
  9|     private static int counter = 0;
 10|     public static int maxAmount = 1024;
 11|     protected static final ObjectSet<Particle> all = new ObjectSet<>();
 12|     protected static final Seq<Particle> temp = new Seq<>();
 13|     protected Vec2 startPos = new Vec2();
 14|     protected float clipSize;
 15|     Cloud currentCloud;
 16|     Cloud firstCloud;
 17|     int cloudCount;
 18|     public Vec2 speed = new Vec2();
 19|     public float size;
 20|     public float defSpeed;
 21|     public float defSize;
 22|     public ParticleModel model;
 23|     public float layer;
 24|     
 25|     public static int count() {
 26|         return all.size;
 27|     }
 28|     
 29|     public static Seq<Particle> get(Boolf<Particle> filter) {
 30|         temp.clear();
 31|         for (Particle particle : all) {
 32|             if (filter.get(particle)) temp.add(particle);
 33|         }
 34|         return temp;
 35|     }
 36|     
 37|     @Override
 38|     public void add() {
 39|         index__all = Groups.all.addIndex(this);
 40|         index__draw = Groups.draw.addIndex(this);
 41|         all.add(this);
 42|         counter++;
 43|         currentCloud = Pools.get(Cloud.class, Cloud::new, 65536).obtain();
 44|         currentCloud.x = x;
 45|         currentCloud.y = y;
 46|         currentCloud.size = 0;
 47|         currentCloud.color.set(model.trailColor(this));
 48|         firstCloud = currentCloud;
 49|         added = true;
 50|         model.init(this);
 51|         if (counter >= maxAmount) {
 52|             remove();
 53|         }
 54|     }
 55|     
 56|     @Override
 57|     public void draw() {
 58|         float l = Draw.z();
 59|         Draw.z(layer);
 60|         model.draw(this);
 61|         if (currentCloud != null) {
 62|             model.drawTrail(this);
 63|         }
 64|         Draw.z(l);
 65|         Draw.reset();
 66|     }
 67|     
 68|     @Override
 69|     public void update() {
 70|         model.deflect(this);
 71|         x += speed.x * Time.delta;
 72|         y += speed.y * Time.delta;
 73|         size = model.currSize(this);
 74|         model.update(this);
 75|         Cloud c = Pools.get(Cloud.class, Cloud::new, 65536).obtain();
 76|         c.x = x;
 77|         c.y = y;
 78|         c.size = size;
 79|         c.color.set(model.trailColor(this));
 80|         c.perCloud = currentCloud;
 81|         currentCloud.nextCloud = c;
 82|         currentCloud = c;
 83|         cloudCount++;
 84|         for (Cloud cloud : currentCloud) {
 85|             model.updateTrail(this, cloud);
 86|         }
 87|         boolean mark = false;
 88|         while (firstCloud.nextCloud != null) {
 89|             if (model.isFaded(this, firstCloud)) {
 90|                 popFirst();
 91|                 mark = true;
 92|             } else break;
 93|         }
 94|         if (!mark && model.isFinal(this)) {
 95|             popFirst();
 96|             if (cloudCount > 4) popFirst();
 97|         }
 98|         if (cloudCount <= 4 && model.isFinal(this)) remove();
 99|     }
100|     
101|     private void popFirst() {
102|         Cloud n = firstCloud.nextCloud;
103|         n.perCloud = null;
104|         Pools.free(firstCloud);
105|         firstCloud = n;
106|         cloudCount--;
107|     }
108|     
109|     @Override
110|     public void remove() {
111|         if (added) {
112|             Groups.all.removeIndex(this, this.index__all);
113|             index__all = -1;
114|             Groups.draw.removeIndex(this, this.index__draw);
115|             index__draw = -1;
116|             Groups.queueFree(this);
117|             all.remove(this);
118|             counter--;
119|             added = false;
120|         }
121|     }
122|     
123|     @Override
124|     public int classId() {
125|         return 102;
126|     }
127|     
128|     @Override
129|     public float clipSize() {
130|         return clipSize = Math.max(Tmp.v1.set(x, y).sub(startPos).len(), clipSize);
131|     }
132|     
133|     @Override
134|     public void reset() {
135|         added = false;
136|         id = EntityGroup.nextId();
137|         lifetime = 0;
138|         region = null;
139|         rotation = 0;
140|         time = 0;
141|         x = 0;
142|         y = 0;
143|         speed.setZero();
144|         startPos.setZero();
145|         layer = 0;
146|         clipSize = 0;
147|         while (firstCloud.nextCloud != null) {
148|             popFirst();
149|         }
150|         Pools.free(firstCloud);
151|         currentCloud = null;
152|         firstCloud = null;
153|         cloudCount = 0;
154|         size = 0;
155|         extra().clear();
156|         model = null;
157|         color.set(Color.white);
158|     }
159|     
160|     @Override
161|     public Iterator<Cloud> iterator() {
162|         return currentCloud.iterator();
163|     }
164|     
165|     public static class Cloud implements Pool.Poolable, Iterable<Cloud> {
166|         
167|         public Cloud() {
168|             super();
169|         }
170|         public final Color color = new Color();
171|         public float x;
172|         public float y;
173|         public float size;
174|         public Cloud perCloud;
175|         public Cloud nextCloud;
176|         Itr itr = new Itr();
177|         
178|         public void draw() {
179|             Draw.color(color);
180|             if (perCloud != null && nextCloud != null) {
181|                 float angle = Angles.angle(x - perCloud.x, y - perCloud.y);
182|                 float dx1 = Angles.trnsx(angle + 90, size);
183|                 float dy1 = Angles.trnsy(angle + 90, size);
184|                 angle = Angles.angle(nextCloud.x - x, nextCloud.y - y);
185|                 float dx2 = Angles.trnsx(angle + 90, nextCloud.size);
186|                 float dy2 = Angles.trnsy(angle + 90, nextCloud.size);
187|                 Fill.quad(x + dx1, y + dy1, x - dx1, y - dy1, nextCloud.x - dx2, nextCloud.y - dy2, nextCloud.x + dx2, nextCloud.y + dy2);
188|             } else if (perCloud == null && nextCloud != null) {
189|                 float angle = Angles.angle(nextCloud.x - x, nextCloud.y - y);
190|                 float dx2 = Angles.trnsx(angle + 90, nextCloud.size);
191|                 float dy2 = Angles.trnsy(angle + 90, nextCloud.size);
192|                 Fill.quad(x, y, x, y, nextCloud.x - dx2, nextCloud.y - dy2, nextCloud.x + dx2, nextCloud.y + dy2);
193|             }
194|         }
195|         
196|         @Override
197|         public void reset() {
198|             x = 0;
199|             y = 0;
200|             size = 0;
201|             color.set(Color.clear);
202|             perCloud = null;
203|             nextCloud = null;
204|         }
205|         
206|         @SuppressWarnings(value = "ReturnOfInnerClass")
207|         @Override
208|         public Iterator<Cloud> iterator() {
209|             itr.reset();
210|             return itr;
211|         }
212|         
213|         class Itr implements Iterator<Cloud> {
214|             
215|             Itr() {
216|                 super();
217|             }
218|             Cloud curr = Cloud.this;
219|             
220|             public void reset() {
221|                 curr = Cloud.this;
222|             }
223|             
224|             @Override
225|             public boolean hasNext() {
226|                 return curr.perCloud != null;
227|             }
228|             
229|             @Override
230|             public Cloud next() {
231|                 return curr = curr.perCloud;
232|             }
233|         }
234|     }
235|     
236|     public java.util.Map<java.lang.String, java.lang.Object> extra() {
237|         return this.extraVar;
238|     }
239| }

